[[dynamic_completions]]
command = "npm"
subcommands = ["run"]
description = "Complete npm script names from package.json"
match_condition = { type = "HasSubcommand" }
shell_command = '''
#!/bin/bash
# Find the nearest package.json file in the current directory or parent directories
find_package_json() {
    local current_dir="$PWD"
    while [ "$current_dir" != "/" ]; do
        if [ -f "$current_dir/package.json" ]; then
            echo "$current_dir/package.json"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done
    if [ -f "./package.json" ]; then
        echo "./package.json"
        return 0
    fi
    return 1
}

PACKAGE_JSON=$(find_package_json)
if [ -z "$PACKAGE_JSON" ]; then
    # No package.json found, exit with no output
    exit 0
fi

# Extract script names from package.json using jq if available
if command -v jq &> /dev/null; then
    cat "$PACKAGE_JSON" | jq -r '.scripts | keys[]' 2>/dev/null || exit 0
else
    # Fallback for systems without jq - extract scripts using grep and sed
    # Get the content between the braces of the scripts object
    sed -n '/"scripts":\s*{/,/},/p' "$PACKAGE_JSON" | \
    sed '1d;$d' | \
    sed 's/^[[:space:]]*"[^"]*"[[:space:]]*:[[:space:]]*"[^"]*"[[:space:]]*,\?/\1/' | \
    sed -n 's/^[[:space:]]*"\([^"]*\)"[[:space:]]*:.*/\1/p' | \
    sed 's/[[:space:]]*$//' | \
    sed '/^$/d'
fi
'''

# Additional configuration to handle npm start/test/build commands that also use script names
[[dynamic_completions]]
command = "npm"
subcommands = ["start", "test", "build"]
description = "Complete npm script names for common aliases (start, test, build)"
match_condition = { type = "HasSubcommand" }
shell_command = '''
#!/bin/bash
# Find the nearest package.json file in the current directory or parent directories
find_package_json() {
    local current_dir="$PWD"
    while [ "$current_dir" != "/" ]; do
        if [ -f "$current_dir/package.json" ]; then
            echo "$current_dir/package.json"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done
    if [ -f "./package.json" ]; then
        echo "./package.json"
        return 0
    fi
    return 1
}

PACKAGE_JSON=$(find_package_json)
if [ -z "$PACKAGE_JSON" ]; then
    # No package.json found, exit with no output
    exit 0
fi

# Extract script names from package.json using jq if available
if command -v jq &> /dev/null; then
    cat "$PACKAGE_JSON" | jq -r '.scripts | keys[]' 2>/dev/null || exit 0
else
    # Fallback for systems without jq - extract scripts using grep and sed
    # Get the content between the braces of the scripts object
    sed -n '/"scripts":\s*{/,/},/p' "$PACKAGE_JSON" | \
    sed '1d;$d' | \
    sed 's/^[[:space:]]*"[^"]*"[[:space:]]*:[[:space:]]*"[^"]*"[[:space:]]*,\?/\1/' | \
    sed -n 's/^[[:space:]]*"\([^"]*\)"[[:space:]]*:.*/\1/p' | \
    sed 's/[[:space:]]*$//' | \
    sed '/^$/d'
fi
'''